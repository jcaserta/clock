<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Pixel Clock — fits browser height</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --grid: 25;
    --tick: #666666;   /* surrounding tick boxes */
    --ink:  #000000;   /* hour + minute (solid) */
    --sec:  #cc0000;   /* seconds (red, filled, multiply) */
    --bg:   #ffffff;
  }

  html, body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    overflow: hidden;
  }

  /* Full viewport; we center a square that's exactly 100vh on wide screens */
  .viewport {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: grid;
    place-items: center;
  }

  /* Square stage == viewport height (so extra side space appears on wide screens) */
  .stage {
    position: relative;
    width: 100vh;
    height: 100vh;
  }

  /* Layers use vh units so each “pixel” is sized from viewport height */
  .layer {
    position: absolute;
    inset: 0;
    display: grid;
    grid-template-columns: repeat(var(--grid), calc(100vh / var(--grid)));
    grid-template-rows:    repeat(var(--grid), calc(100vh / var(--grid)));
    pointer-events: none;
  }

  /* seconds layer multiplies over black hands */
  .layer.seconds { mix-blend-mode: multiply; }

  .px { background: transparent; }
  .tick { background: var(--tick); }
  .fill { background: var(--ink); }      /* minute */
  .fillHour { background: var(--ink); }  /* hour (half length) */
  .sec { background: var(--sec); }       /* seconds: filled red */

  * { user-select: none; -webkit-user-select: none; }
</style>
</head>
<body>
  <div class="viewport">
    <div class="stage">
      <div id="ticks"   class="layer"></div>
      <div id="hands"   class="layer"></div>
      <div id="seconds" class="layer seconds"></div>
    </div>
  </div>

<script>
(() => {
  const G  = 25;
  const CX = Math.floor(G/2), CY = Math.floor(G/2);
  const PAD = 1;
  const MAXR = Math.floor(G/2) - PAD;

  const elTicks   = document.getElementById('ticks');
  const elHands   = document.getElementById('hands');
  const elSeconds = document.getElementById('seconds');

  // Build 3 overlapped grids
  const mkCells = (container) => {
    const arr = [];
    for (let y=0;y<G;y++){
      for (let x=0;x<G;x++){
        const d = document.createElement('div');
        d.className = 'px';
        container.appendChild(d);
        arr.push(d);
      }
    }
    return arr;
  };
  const ticksCells   = mkCells(elTicks);
  const handsCells   = mkCells(elHands);
  const secondsCells = mkCells(elSeconds);
  const idx = (x,y)=> y*G + x;

  // Bresenham line
  function lineCells(x0,y0,x1,y1){
    const out=[];
    let dx=Math.abs(x1-x0), sx=x0<x1?1:-1;
    let dy=-Math.abs(y1-y0), sy=y0<y1?1:-1;
    let err=dx+dy, e2;
    for(;;){
      out.push([x0,y0]);
      if(x0===x1 && y0===y1) break;
      e2=2*err;
      if(e2>=dy){ err+=dy; x0+=sx; }
      if(e2<=dx){ err+=dx; y0+=sy; }
    }
    return out;
  }

  // polar (0 at 12 o’clock) -> grid coord
  function polar(theta, r){
    const gx = CX + Math.round(Math.sin(theta) * r);
    const gy = CY - Math.round(Math.cos(theta) * r);
    return [gx, gy];
  }

  // Static ticks (#666 around the ring)
  (function drawTicks(){
    const tickList=[];
    for(let k=0;k<12;k++){
      const ang = (Math.PI*2)*(k/12);
      tickList.push(polar(ang, MAXR));
    }
    for(const [x,y] of tickList){
      ticksCells[idx(x,y)].className = 'px tick';
    }
  })();

  function clearHands(){
    for(const d of handsCells)   d.className = 'px';
    for(const d of secondsCells) d.className = 'px';
  }

  function draw(){
    clearHands();

    const now = new Date();
    const s  = now.getSeconds();
    const m  = now.getMinutes();
    const hr = now.getHours()%12;

    // Discrete angles
    const secAng  = (Math.PI*2)*(s/60);
    const minAng  = (Math.PI*2)*(m/60);
    const hourIdx = (hr*5) + Math.floor(m/5);
    const hourAng = (Math.PI*2)*(hourIdx/60);

    // Lengths
    const secLen  = MAXR;
    const minLen  = MAXR-1;
    const hourLen = Math.max(2, Math.round(MAXR*0.5)); // half length

    const [sx,sy] = polar(secAng,  secLen);
    const [mx,my] = polar(minAng,  minLen);
    const [hx,hy] = polar(hourAng, hourLen);

    const secPath  = lineCells(CX,CY,sx,sy);
    const minPath  = lineCells(CX,CY,mx,my);
    const hourPath = lineCells(CX,CY,hx,hy);

    // Minutes: solid black
    for(const [x,y] of minPath){
      if(x>=0&&x<G&&y>=0&&y<G) handsCells[idx(x,y)].className = 'px fill';
    }
    // Hour: solid black, half-length
    for(const [x,y] of hourPath){
      if(x>=0&&x<G&&y>=0&&y<G) handsCells[idx(x,y)].className = 'px fillHour';
    }
    // Seconds: solid red with multiply on its own layer
    for(const [x,y] of secPath){
      if(x>=0&&x<G&&y>=0&&y<G) secondsCells[idx(x,y)].className = 'px sec';
    }
  }

  // Align to next second, then tick
  function start(){
    draw();
    const now = new Date();
    const delay = 1000 - (now.getMilliseconds()%1000);
    setTimeout(()=>{ draw(); setInterval(draw,1000); }, delay);
  }

  start();
})();
</script>
</body>
</html>