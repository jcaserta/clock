<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Pixel Clock — 32×32 grid, extended minute hand</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --grid: 32;        /* 32×32 grid */
    --tick: #666666;   /* surrounding tick boxes */
    --ink:  #000000;   /* hour + minute (solid) */
    --sec:  #cc0000;   /* seconds (red, filled, multiply) */
    --bg:   #ffffff;
  }
  html, body { margin:0; height:100%; background:var(--bg); overflow:hidden; }
  .viewport { position:relative; width:100vw; height:100vh; display:grid; place-items:center; }
  .stage { position:relative; width:100vh; height:100vh; }

  .layer{
    position:absolute; inset:0; display:grid; pointer-events:none;
    grid-template-columns:repeat(var(--grid), calc(100vh / var(--grid)));
    grid-template-rows:   repeat(var(--grid), calc(100vh / var(--grid)));
  }
  .layer.seconds{ mix-blend-mode:multiply; }

  .px{ background:transparent; }
  .tick{ background:var(--tick); }
  .fill{ background:var(--ink); }       /* minute */
  .fillHour{ background:var(--ink); }   /* hour (half length) */
  .sec{ background:var(--sec); }        /* seconds (filled red) */

  *{ user-select:none; -webkit-user-select:none; }
</style>
</head>
<body>
  <div class="viewport">
    <div class="stage">
      <div id="ticks"   class="layer"></div>
      <div id="hands"   class="layer"></div>
      <div id="seconds" class="layer seconds"></div>
    </div>
  </div>

<script>
(() => {
  const G  = 32;
  const CX = Math.floor(G/2), CY = Math.floor(G/2);
  const PAD = 1;
  const MAXR = Math.floor(G/2) - PAD;      // radius to the tick ring

  const elTicks   = document.getElementById('ticks');
  const elHands   = document.getElementById('hands');
  const elSeconds = document.getElementById('seconds');

  // Build layers
  const mkCells = (container) => {
    const arr = [];
    for (let y=0;y<G;y++){
      for (let x=0;x<G;x++){
        const d = document.createElement('div');
        d.className = 'px';
        container.appendChild(d);
        arr.push(d);
      }
    }
    return arr;
  };
  const ticksCells   = mkCells(elTicks);
  const handsCells   = mkCells(elHands);
  const secondsCells = mkCells(elSeconds);
  const idx = (x,y)=> y*G + x;

  // Bresenham line
  function lineCells(x0,y0,x1,y1){
    const out=[];
    let dx=Math.abs(x1-x0), sx=x0<x1?1:-1;
    let dy=-Math.abs(y1-y0), sy=y0<y1?1:-1;
    let err=dx+dy, e2;
    for(;;){
      out.push([x0,y0]);
      if(x0===x1 && y0===y1) break;
      e2=2*err;
      if(e2>=dy){ err+=dy; x0+=sx; }
      if(e2<=dx){ err+=dx; y0+=sy; }
    }
    return out;
  }

  // Polar (0 at 12 o’clock) → grid coordinate
  function polar(theta, r){
    const gx = CX + Math.round(Math.sin(theta) * r);
    const gy = CY - Math.round(Math.cos(theta) * r);
    return [gx, gy];
  }

  // Static ticks
  (function drawTicks(){
    for(let k=0;k<12;k++){
      const [tx,ty] = polar((Math.PI*2)*(k/12), MAXR);
      if(tx>=0&&tx<G&&ty>=0&&ty<G) ticksCells[idx(tx,ty)].className = 'px tick';
    }
  })();

  function clearHands(){ for(const d of handsCells)   d.className = 'px'; }
  function clearSeconds(){ for(const d of secondsCells) d.className = 'px'; }

  // Draw hour + minute (minute updates each minute; hour is fractional with minutes)
  function drawHands(){
    clearHands();

    const now = new Date();
    const m   = now.getMinutes();
    const hr  = now.getHours()%12;

    const minAng  = (Math.PI*2)*(m/60);
    const hourAng = (Math.PI*2)*((hr + m/60)/12);

    // ⇐ Minute length now matches seconds (reaches the outer ring)
    const minLen  = MAXR;
    const hourLen = Math.max(2, Math.round(MAXR*0.5));

    const [mx,my] = polar(minAng,  minLen);
    const [hx,hy] = polar(hourAng, hourLen);

    const minPath  = lineCells(CX,CY,mx,my);
    const hourPath = lineCells(CX,CY,hx,hy);

    for(const [x,y] of minPath){
      if(x>=0&&x<G&&y>=0&&y<G) handsCells[idx(x,y)].className = 'px fill';
    }
    for(const [x,y] of hourPath){
      if(x>=0&&x<G&&y>=0&&y<G) handsCells[idx(x,y)].className = 'px fillHour';
    }
  }

  // Continuous seconds using milliseconds
  function drawSeconds(){
    clearSeconds();
    const now = new Date();
    const s   = now.getSeconds() + now.getMilliseconds()/1000;
    const secAng = (Math.PI*2)*(s/60);
    const secLen = MAXR;

    const [sx,sy] = polar(secAng, secLen);
    const secPath = lineCells(CX,CY,sx,sy);

    for(const [x,y] of secPath){
      if(x>=0&&x<G&&y>=0&&y<G) secondsCells[idx(x,y)].className = 'px sec';
    }
  }

  function loopSeconds(){
    drawSeconds();
    requestAnimationFrame(loopSeconds);
  }

  function start(){
    drawHands();
    loopSeconds();
    // align minute/hour updates to second edge
    const now = new Date();
    const delay = 1000 - (now.getMilliseconds()%1000);
    setTimeout(()=>{ drawHands(); setInterval(drawHands, 1000); }, delay);
  }

  start();
})();
</script>
</body>
</html>